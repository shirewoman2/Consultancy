---
title: "Fitted induction data"
author: SimcypConsultancy package version `r packageVersion("SimcypConsultancy")`
date: "Compiled on `r format(Sys.time(), '%B %d, %Y')`"
output: word_document
---

```{r setupindfit, echo=FALSE}

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, 
                      dpi = 600)

```


# Induction models available -- CHANGE THE TEXT BELOW AS NEEDED

***Note:*** *Some of these models will give you Ind~max~ and some will give you E~max~, so pay careful attention to which parameter each model fits. The Simcyp Simulator uses Ind~max~ as input. For converting between the two: $Ind_{max} = E_{max} + 1$ and IndC~50~ is the same thing as EC~50~.*

Four induction models (Equations 1, 2, 3, and 4) were fit to the *in vitro* induction data. 

*Equation 1. E~max~ model* 

$$ \text{fold induction} = 1 + \frac{E_{max} \times I}{EC_{50} + I} $$ 

where I is the concentration of the inducer, E~max~ is the maximum change in fold induction, and EC~50~ is the concentration of the inducer that elicits half the maximum fold-change in induction. 

*Equation 2. E~max~ slope model* 

$$ \text{fold induction} = 1 + E_{max} \times \frac{I^\gamma}{EC_{50}^\gamma + I^\gamma} $$

where I is the concentration of the inducer, E~max~ is the maximum change in fold induction, EC~50~ is the concentration of the inducer that elicits half the maximum fold-change in induction, and &gamma; is the Hill equation coefficient describing the slope. 

*Equation 3. Slope model* 

$$ \text{fold induction} = 1 + I \times n $$

where I is the concentration of the inducer and n is the slope. 

*Equation 4. Sigmoidal three-parameter model* 

$$ \text{fold induction} = \frac{Ind_{max}}{1 + e^{ \frac{IndC_{50}-I}{\gamma}}} $$

where I is the concentration of the inducer, Ind~max~ is the maximum fold induction, IndC~50~ is the concentration of the inducer that elicits half the maximum fold induction, and &gamma; is the Hill equation coefficient describing the slope. 



```{r indFit_ind}

model_label <- switch(model, 
                      "EmaxSlope" = "E~max~ slope model", 
                      "Slope" = "slope model", 
                      "Sig3Param" = "sigmoidal three-parameter model", 
                      "Emax" = "E~max~ model", 
                      "all" = "E~max~, E~max~ slope, sigmoidal three-parameter, and slope models")


```


*Figure XXX. `r ifelse(model == "all", "Fits", "Fit")` of the `r model_label` to`r ifelse(is.na(enzyme), "", paste0(" ", enzyme))` `r measurement` fold-change data after incubations of human hepatocytes`r ifelse(complete.cases(drug), paste0(" with ", drug, "."), ".")`*

```{r indFit_sum, fig.width = fig_width, fig.height = fig_height}

Out$Graph

if(model == "all"){
    FitsThatWorked <- unique(Out$Fit$Model)    
} else {
    FitsThatWorked <- model
}

GoodMod <-  c("EmaxSlope" = "E~max~ slope", 
              "Slope" = "slope", 
              "Sig3Param" = "sigmoidal three-parameter", 
              "Emax" = "E~max~")
FitsThatWorked <- GoodMod[FitsThatWorked]
FitsThatWorked <- paste(str_comma(FitsThatWorked), 
                        ifelse(length(FitsThatWorked) == 1, "model", "models"))

```


*`r ifelse(model == "all", "Models were", "The model was")` fit to the `r ifelse(fitByDonor, "individual", "mean")` data, and lines represent successful fits; where fits failed to converge, no line is shown.*

*Table XXX. Fitted parameters for the `r FitsThatWorked` for `r ifelse(is.na(enzyme), "", paste0(" ", enzyme))` `r measurement` fold-change data after incubations of human hepatocytes`r ifelse(complete.cases(drug), paste0(" with ", drug, "."), ".")`*

```{r indfit3}

if(model == "all" & fitByDonor){
    
    Fit_ind <- Out$Fit
    
    suppressWarnings(
        Fit_sum <- Fit_ind %>% group_by(Model) %>% 
            summarize(across(.cols = everything(), .fns = mean, na.rm = T)) %>% 
            mutate(DonorID = "mean")
    )
    
    AllFits <- bind_rows(Fit_ind, Fit_sum) %>% 
        mutate(DonorID = as.factor(DonorID),
               DonorID = forcats::fct_relevel(DonorID, "mean", after = Inf)) %>% 
        arrange(Model, DonorID)
    
} else {
    # Not fit by donor here, so not calculating means
    AllFits <- Out$Fit
}

# Making "model" look nice for the table
AllFits <- AllFits %>% 
    mutate(Model = case_when(Model == "Emax" ~ "Emax", 
                             Model == "EmaxSlope" ~ "Emax slope", 
                             Model == "Sig3Param" ~ "sigmoidal 3-parameter", 
                             Model == "Slope" ~ "slope")) %>% 
    
    # Rounding as requested
    mutate(across(.cols = any_of(c("Emax", "EC50", "Gamma", "slope", "IndC50", "Indmax")), 
                  .fns = round_opt, 
                  round_fun = ifelse(complete.cases(rounding) && rounding == "Word only", 
                                     "Consultancy", rounding)))

MeanRows <- which(AllFits$DonorID == "mean")

if(model == "all"){
    AllFits <- AllFits %>% 
        formatTable_Simcyp(shading_column = Model, 
                           bold_cells = list(c(0, NA)), 
                           center_1st_column = TRUE) 
} else {
    AllFits <- AllFits %>% 
        formatTable_Simcyp(bold_cells = list(c(0, NA)), 
                           center_1st_column = TRUE) 
}

AllFits %>% 
    flextable::bold(i = MeanRows) %>% 
    flextable::merge_v(j = 1) %>% 
    flextable::hline_bottom(border = officer::fp_border(width = 0.5))

```

`r ifelse(FitsThatWorked == model_label, "", "*Only fits that converged are shown in the table.*")`

