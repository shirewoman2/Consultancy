#' Overlay multiple data sets onto a single concentration-time graph
#'
#' \code{ct_plot_overlay} is meant to be used in conjunction with
#' \code{\link{extractConcTime_mult}} to create single graphs with overlaid
#' concentration-time data for multiple tissues, compounds, or Simcyp Simulator
#' output files for easy comparisons. \emph{Note:} There are some nuances to
#' overlaying observed data. Please see the "Details" section at the bottom of
#' this help file. 
#'
#' \strong{Notes on including observed data:} We recently added the option of
#' including observed data and are in the process of testing this. To include
#' observed data, you have two options: \enumerate{
#'
#' \item{Use the Simulator Excel PE data entry template to save your observed
#' data. Then, when you run \code{\link{extractConcTime_mult}}, supply the names
#' of those Excel files to the observed data  function argument. This is the
#' BEST option because it contains the most information about the observed
#' data.}
#'
#' \item{Include observed data in your simulation files. Those data will be
#' automatically extracted when you run \code{\link{extractConcTime_mult}} if
#' "obs_data_files" is left as the default NA. The drawback to this approach is
#' that it's not clear whether there was an inhibitor present, for example, or
#' which compound the data describe.} }
#'
#' The \code{ct_plot_overlay} function will automatically figure out which
#' observed data should be compared with which simulated compound IDs, tissues,
#' etc. However, because the function doesn't know which simulator \emph{file}
#' goes with which observed data, it will assume that \emph{all} the observed
#' data are appropriate to compare to \emph{all} the files included in
#' \code{ct_dataframe} by default. If that's not the case, after you use
#' \code{\link{extractConcTime_mult}} to extract your data, you can indicate
#' which simulator output file goes with which observed file by setting the
#' simulator output file in the column "File". This admittedly requires a bit of
#' R knowledge, so please ask a member of the R Working Group for help if you're
#' not clear on how to do this. Be warned, though, that if you assign "File" for
#' some observed data but not all, only the observed data with an assignment for
#' "File" will show up on the graph.
#'
#' One other note: The observed data files from the PE data-entry template don't
#' include the \emph{name} of the compound you're simulating (column:
#' "Compound"). They do include whether it was a substrate, metabolite, or
#' inhibitor (column: CompoundID), but not the compound's actual name. For that
#' reason, try coloring or facetting your data by CompoundID rather than by
#' Compound if you have observed data. Similarly, if you have an inhibitor and
#' you have observed data, the inhibitor will be listed as the generic
#' "inhibitor" here rather than, e.g., "ketoconazole" because the observed data
#' file doesn't indicate that.
#'
#' \strong{Other notes:} There's a bug in RStudio (I think) that sometimes
#' causes the last shape in a legend to vanish when you're looking at the graph
#' in RStudio, but, if you save the graph, the shape \emph{should} be present.
#' Let me know if that doesn't happen. -LSh
#'
#' @param ct_dataframe the input concentration-time data generated by running
#'   the function \code{\link{extractConcTime_mult}} or
#'   \code{\link{extractConcTime}}. Not quoted.
#' @param obs_to_sim_assignment optionally specify which observed files should
#'   be compared to which simulator files. If left as NA and what you supplied
#'   for \code{ct_dataframe} doesn't already specify which observed data go with
#'   which simulated file, this will assume that \emph{all} observed data goes
#'   with \emph{all} simulated data. To specify, use a named character vector
#'   like this: \code{obs_to_sim_assignment = c("obs data 1.xlsx" =
#'   "mdz-5mg-qd.xlsx", "obs data 2.xlsx" = "mdz-5mg-qd-cancer.xlsx")} If one
#'   observed file needs to match more than one simulated file but not
#'   \emph{all} the simulated files, you can do that by separating the simulated
#'   files with commas, e.g., \code{obs_to_sim_assignment = c("obs data 1.xlsx"
#'   = "mdz-5mg-qd.xlsx, mdz-5mg-qd-fa08.xlsx", "obs data 2.xlsx" =
#'   "mdz-5mg-qd-cancer.xlsx, mdz-5mg-qd-cancer-fa08.xlsx")}. Pay close
#'   attention to the position of commas and quotes there!
#' @param mean_type plot "arithmetic" (default) or "geometric" mean
#'   concentrations or "median" concentrations as the main (thickest or only)
#'   line for each data set. If this aggregate measure is not available in the
#'   simulator output, you'll receive a warning message and we'll plot one that
#'   \emph{is} available.
#' @param figure_type the type of figure to plot. \describe{
#'
#'   \item{"means only"}{(default) show only the mean, geometric mean, or median
#'   (whatever you chose for "mean_type")}
#'
#'   \item{"percentiles"}{plots an opaque line for the mean data and lighter
#'   lines for the 5th and 95th percentiles of the simulated data}
#'
#'   \item{"percentile ribbon"}{show an opaque line for the mean data and
#'   transparent shading for the 5th to 95th percentiles. Note: You may
#'   sometimes see some artifacts -- especially for semi-log plots -- where the
#'   ribbon gets partly cut off. For arcane reasons we don't want to bore you
#'   with here, we can't easily prevent this. To fix this, increase your y axis
#'   limits for the semi-log plot.}}
#' @param linear_or_log the type of graph to be returned. Options: \describe{
#'   \item{"semi-log"}{y axis is log transformed; this is the default}
#'
#'   \item{"linear"}{no axis transformation}
#'
#'   \item{"both vertical"}{both the linear and the semi-log graphs will be
#'   returned, and graphs are stacked vertically}
#'
#'   \item{"both horizontal"}{both the linear and the semi-log graphs will be
#'   returned, and graphs are stacked horizontally}}
#' @param colorBy_column (optional) the column in \code{ct_dataframe} that
#'   should be used for determining which color lines and/or points will be.
#'   This should be unquoted, e.g., \code{colorBy_column = Tissue}.
#' @param color_labels optionally specify a character vector for how you'd like
#'   the labels for whatever you choose for \code{colorBy_column} to show up in
#'   the legend. For example, use \code{c("file 1.xlsx" = "fa 0.5", "file
#'   2.xlsx" = "fa 0.2")} to indicate that "file 1.xlsx" is for an fa of 0.5 and
#'   "file 2.xlsx" is for an fa of 0.2. The order in the legend will match the
#'   order designated here.
#' @param legend_label_color optionally indicate on the legend something
#'   explanatory about what the colors represent. For example, if
#'   \code{colorBy_column = File} and \code{legend_label_color = "Simulations
#'   with various fa values"}, that will make the label above the file names in
#'   the legend more explanatory than just "File". The default is to use
#'   whatever the column name is for \code{colorBy_column}. If you don't want a
#'   label for this legend item, set this to "none".
#' @param color_set the set of colors to use. Options: \describe{
#'
#'   \item{"default"}{a set of colors from Cynthia Brewer et al. from Penn State
#'   that are friendly to those with red-green colorblindness. The first three
#'   colors are green, orange, and purple. This can also be referred to as
#'   "Brewer set 2". If there are only two unique values in the colorBy_column,
#'   then Brewer set 1 will be used since red and blue are still easily
#'   distinguishable but also more aesthetically pleasing than green and
#'   orange.}
#'
#'   \item{"Brewer set 1"}{colors selected from the Brewer palette "set 1". The
#'   first three colors are red, blue, and green.}
#'
#'   \item{"ggplot2 default"}{the default set of colors used in ggplot2 graphs
#'   (ggplot2 is an R package for graphing.)}
#'
#'   \item{"rainbow"}{colors selected from a rainbow palette. The default
#'   palette is limited to something like 6 colors, so if you have more than
#'   that, that's when this palette is most useful. It's \emph{not} very useful
#'   when you only need a couple of colors.}
#'
#'   \item{"blue-green"}{a set of blues fading into greens. This palette can be
#'   especially useful if you are comparing a systematic change in some
#'   continuous variable -- for example, increasing dose or predicting how a
#'   change in intrinsic solubility will affect concentration-time profiles --
#'   because the direction of the trend will be clear.}
#'
#'   \item{"blues"}{a set of blues fading light blue to dark blue. Like
#'   "blue-green", this palette can be especially useful if you are comparing a
#'   systematic change in some continuous variable.}
#'
#'   \item{"Tableau"}{uses the standard Tableau palette; requires the "ggthemes"
#'   package}
#'
#'   \item{"viridis"}{from the eponymous package by Simon Garnier and ranges
#'   colors from purple to blue to green to yellow in a manner that is
#'   "printer-friendly, perceptually uniform and easy to read by those with
#'   colorblindness", according to the package author}
#'
#'   \item{a character vector of colors}{If you'd prefer to set all the colors
#'   yourself to \emph{exactly} the colors you want, you can specify those
#'   colors here. An example of how the syntax should look: \code{color_set =
#'   c("dodgerblue3", "purple", "#D8212D")} or, if you want to specify exactly
#'   which item in \code{colorBy_column} gets which color, you can supply a
#'   named vector. For example, if you're coloring the lines by the compound ID,
#'   you could do this: \code{color_set = c("substrate" = "dodgerblue3",
#'   "inhibitor 1" = "purple", "primary metabolite 1" = "#D8212D")}. If you'd
#'   like help creating a specific gradation of colors, please talk to a member
#'   of the R Working Group about how to do that using
#'   \link{colorRampPalette}.}}
#'
#' @param obs_shape optionally specify what shapes are used to depict observed
#'   data for a) the substrate drug alone and b) the substrate drug in the
#'   presence of an effector. Input should look like this, for example:
#'   \code{c(1, 2)} to get an open circle for the substrate and an open triangle
#'   for the substrate in the presence of effectors, if there are any. If you
#'   only specify one value, it will be used for both substrate with and without
#'   effectors. To see all the possible shapes and what number corresponds to
#'   which shape, type \code{ggpubr::show_point_shapes()} into the console. If
#'   left as NA, substrate alone will be an open circle and substrate +
#'   inhibitor 1 will be an open triangle.
#' @param obs_size optionally specify the size of the points to use for the
#'   observed data. If left as NA, the size will be 2.
#' @param obs_color optionally specify a color to use for observed data if the
#'   color isn't already mapped to a specific column. By default, observed data
#'   will be the same color as whatever else matches those observed data in
#'   \code{colorBy_column}, so if you have colored by compound ID, for example,
#'   the observed data will also be colored by compound ID. If you have one
#'   observed file that you're comparing to multiple simulation files (this is
#'   what ct_plot_overlay will do if "File" is NA for the observed data), then
#'   the observed data will all be black by default, or you could set that color
#'   to be, say, a lovely purple by setting this: \code{obs_color =
#'   "darkorchid4"}. Hex color codes are also ok to use, and setting this to
#'   "none" will remove observed data from the graph.
#' @param obs_fill_trans optionally specify the transparency for the fill of the
#'   observed data points, which can be helpful when you have a lot of points
#'   overlapping. This only applies when you have specified a value for
#'   \code{obs_color} and when \code{obs_shape} is a shape that has a fill
#'   (example: \code{obs_shape = 21} for a filled circle, which is the default).
#'   Acceptable values are from 0 (fully transparent, so no fill at all) to 1
#'   (completely opaque or black). If left as the default NA, the observed data
#'   points will be 50 percent transparent, so the same as if this were set to
#'   0.5.
#' @param obs_line_trans optionally specify the transparency for the outline of
#'   the observed data points, which can be helpful when you have a lot of
#'   points overlapping. Acceptable values are from 0 (fully transparent, so no
#'   line at all) to 1 (completely opaque or black). If left as the default NA,
#'   the observed data points will be opaque, so the same as if this were set to
#'   1.
#' @param linetype_column the column in \code{ct_dataframe} that should be used
#'   for determining the line types and also the shapes of the points for
#'   depicting any observed data. For example, if \code{linetype_column} is set
#'   to \code{Inhibitor}, then the default is to show a solid line (simulated
#'   data) and an open circle (observed data) for no inhibitor being present and
#'   then a dashed line (simulated data) and an open triangle (observed data)
#'   when the inhibitor \emph{is} present. You can set which types of lines to
#'   use with the argument \code{linetypes} and you can set which shapes of
#'   points you want with the argument \code{obs_shape}.
#' @param linetypes the line types to use. Default is "solid" for all lines.
#'   You'll need one line type for each possible value in the column you
#'   specified for \code{linetype_column}. If you get a graph you didn't expect
#'   as far as line types go, try checking what all the possible values are for
#'   the column you specified for \code{linetype_column}. You can do this by
#'   checking, e.g., \code{unique(CT$Inhibitor)} if your ct_dataframe was named
#'   "CT" and the column you set for \code{linetype_column} was "Inhibitor". To
#'   see possible line types by name, please enter
#'   \code{ggpubr::show_line_types()} into the console.
#' @param line_width optionally specify how thick to make the lines. Acceptable
#'   input is a number; the default is 1 for most lines and 0.8 for some, to
#'   give you an idea of where to start.
#' @param legend_label_linetype optionally indicate on the legend something
#'   explanatory about what the line types represent. For example, if
#'   \code{linetype_column = Inhibitor} and \code{legend_label_linetype =
#'   "Inhibitor present"}, that will make the label in the legend above, e.g.,
#'   "none", and whatever effector was present more explanatory than just
#'   "Inhibitor". The default is to use whatever the column name is for
#'   \code{linetype_column}. If you don't want a label for this legend item, set
#'   this to "none".
#' @param facet1_column optionally break up the graph into small multiples; this
#'   specifies the first of up to two columns to break up the data by, and the
#'   designated column name should be unquoted, e.g., \code{facet1_column =
#'   Tissue}. If \code{floating_facet_scale} is FALSE and you haven't specified
#'   \code{facet_ncol} or  \code{facet_nrow}, then \code{facet1_column} will
#'   designate the rows of the output graphs.
#' @param facet2_column optionally break up the graph into small multiples; this
#'   specifies the second of up to two columns to break up the data by, and the
#'   designated column name should be unquoted, e.g., \code{facet2_column =
#'   CompoundID}. If \code{floating_facet_scale} is FALSE and you haven't
#'   specified \code{facet_ncol} or  \code{facet_nrow}, then
#'   \code{facet2_column} will designate the columns of the output graphs.
#' @param facet_ncol optionally specify the number of columns of facetted graphs
#'   you would like to have. This only applies when you have specified a column
#'   for \code{facet1_column} and/or \code{facet2_column}.
#' @param facet_nrow optionally specify the number of rows of facetted graphs
#'   you would like to have. This only applies when you have specified a column
#'   for \code{facet1_column} and/or \code{facet2_column}.
#' @param floating_facet_scale TRUE or FALSE (default) for whether to allow the
#'   axes for each facet of a multi-facetted graph to scale freely to best fit
#'   whatever data are present. Default is FALSE, which means that all data will
#'   be on the same scale for easy comparison. However, this could mean that
#'   some graphs have lines that are hard to see, so you can set this to TRUE to
#'   allow the axes to shrink or expand according to what data are present for
#'   that facet. Floating axes comes with a trade-off for the looks of the
#'   graphs, though: Setting this to TRUE does mean that your x axis won't
#'   automatically have pretty breaks that are sensible for times in hours.
#' @param facet_spacing Optionally set the spacing between facets. If left as
#'   NA, a best-guess as to a reasonable amount of space will be used. Units are
#'   "lines", so try, e.g. \code{facet_spacing = 2}. (Reminder: Numeric data
#'   should not be in quotes.)
#' @param time_range time range to display. Options: \describe{
#'
#'   \item{NA}{entire time range of data; default}
#'
#'   \item{a start time and end time in hours}{only data in that time range,
#'   e.g. \code{c(24, 48)}. Note that there are no quotes around numeric data.}
#'
#'   \item{"first dose"}{only the time range of the first dose}
#'
#'   \item{"last dose"}{only the time range of the last dose}
#'
#'   \item{"penultimate dose"}{only the time range of the 2nd-to-last dose,
#'   which can be useful for BID data where the end of the simulation extended
#'   past the dosing interval or data when the substrate was dosed BID and the
#'   effector was dosed QD}
#'
#'   \item{a specific dose number with "dose" or "doses" as the prefix}{the time
#'   range encompassing the requested doses, e.g., \code{time_range = "dose 3"}
#'   for the 3rd dose or \code{time_range = "doses 1 to 4"} for doses 1 to 4}
#'
#'   \item{"all obs" or "all observed" if you feel like spelling it out}{Time
#'   range will be limited to only times when observed data are present.}
#'
#'   \item{"last dose to last observed" or "last obs" for short}{Time range will
#'   be limited to the start of the last dose until the last observed data
#'   point.} }
#'
#' @param x_axis_interval set the x-axis major tick-mark interval. Acceptable
#'   input: any number or leave as NA to accept default values, which are
#'   generally reasonable guesses as to aesthetically pleasing and PK-relevant
#'   intervals.
#' @param x_axis_label optionally supply a character vector or an expression to
#'   use for the x axis label
#' @param pad_x_axis optionally add a smidge of padding to the x axis (default
#'   is TRUE, which includes some generally reasonable padding). If changed to
#'   FALSE, the y axis will be placed right at the beginning of your time range
#'   and all data will end \emph{exactly} at the end of the time range
#'   specified. If you want a \emph{specific} amount of x-axis padding, set this
#'   to a number; the default is \code{c(0.02, 0.04)}, which adds 2\% more space
#'   to the left side and 4\% more space to the right side of the x axis. If you
#'   only specify one number, padding is added to the left side.
#' @param pad_y_axis optionally add a smidge of padding to the y axis (default
#'   is TRUE, which includes some generally reasonable padding). As with
#'   \code{pad_x_axis}, if changed to FALSE, the x axis will be placed right at
#'   the bottom of your data, possible cutting a point in half. If you want a
#'   \emph{specific} amount of y-axis padding, set this to a number; the default
#'   is \code{c(0.02, 0)}, which adds 2\% more space to the bottom and nothing
#'   to the top of the y axis. If you only specify one number, padding is added
#'   to the bottom.
#' @param y_axis_limits_lin Optionally set the Y axis limits for the linear
#'   plot, e.g., \code{c(10, 1000)}. If left as NA, the Y axis limits for the
#'   linear plot will be automatically selected. This only applies when you have
#'   requested a linear plot with \code{linear_or_log}.
#' @param y_axis_limits_log Optionally set the Y axis limits for the semi-log
#'   plot, e.g., \code{c(10, 1000)}. Values will be rounded down and up,
#'   respectively, to the nearest order of magnitude. If left as NA, the Y axis
#'   limits for the semi-log plot will be automatically selected. This only
#'   applies when you have requested a semi-log plot with \code{linear_or_log}.
#' @param y_axis_label optionally supply a character vector or an expression to
#'   use for the y axis label
#' @param graph_labels TRUE or FALSE for whether to include labels (A, B, C,
#'   etc.) for each of the small graphs. (Not applicable if only outputting
#'   linear or only semi-log graphs.)
#' @param graph_title optionally specify a title that will be centered across
#'   your graph or set of graphs
#' @param graph_title_size the font size for the graph title if it's included;
#'   default is 14. This also determines the font size of the graph labels. 
#' @param legend_position Specify where you want the legend to be. Options are
#'   "left", "right" (default in most scenarios), "bottom", "top", or "none" if
#'   you don't want one at all.
#' @param prettify_compound_names set this to a) TRUE (default) or FALSE for
#'   whether to make the compound names in the legend prettier or b) supply a
#'   named character vector to set it to the exact name you'd prefer to see in
#'   your legend. For example, \code{prettify_compound_names =
#'   c("Sim-Ketoconazole-400 mg QD" = "ketoconazole", "Wks-Drug ABC-low_ka" =
#'   "Drug ABC")} will make those compounds "ketoconazole" and "Drug ABC" in a
#'   legend, and \code{prettify_compound_names = TRUE} will make some reasonable
#'   guesses about what a prettier compound name should be. An example of
#'   setting this to TRUE: "SV-Rifampicin-MD" would become "rifampicin", and
#'   "Sim-Ketoconazole-200 mg BID" would become "ketoconazole".
#' @param save_graph optionally save the output graph by supplying a file name
#'   in quotes here, e.g., "My conc time graph.png"or "My conc time graph.docx".
#'   The nice thing about saving to Word is that the figure title and caption
#'   text will be partly filled in automatically, although you should check that
#'   the text makes sense in light of your exact graph. If you leave off ".png"
#'   or ".docx", it will be saved as a png file, but if you specify a different
#'   graphical file extension, it will be saved as that file format. Acceptable
#'   graphical file extensions are "eps", "ps", "jpeg", "jpg", "tiff", "png",
#'   "bmp", or "svg". Leaving this as NA means the file will not be
#'   automatically saved to disk. \strong{WARNING:} SAVING TO WORD DOES NOT WORK
#'   ON SHAREPOINT. This is a Microsoft permissions issue, not an R issue. If
#'   you try to save on SharePoint, you will get a warning that R will save your
#'   file instead to your Documents folder.
#' @param fig_height figure height in inches; default is 6
#' @param fig_width figure width in inches; default is 5
#'
#' @return
#' @export
#'
#' @examples
#' data(MDZct)
#' ct_plot_overlay(ct_dataframe = MDZct, colorBy_column = File)
#'
#' # Setting the legend labels for color to be more interpretable. Note
#' # that the order matches the order listed here, not the alphabetical
#' # order of the files.
#' ct_plot_overlay(ct_dataframe = MDZct, colorBy_column = File,
#'                 color_labels = c("mdz-5mg-sd-fa1.xlsx" = "fa 1",
#'                                  "mdz-5mg-sd-fa0_8.xlsx" = "fa 0.8",
#'                                  "mdz-5mg-sd-fa0_6.xlsx" = "fa 0.6",
#'                                  "mdz-5mg-sd-fa0_4.xlsx" = "fa 0.4"))
#'
#' # An example of how you might set the column "File" for a specific
#' # observed data file:
#' MyData <- MyData %>%
#'    mutate(File = case_when(ObsFile == "ObservedData1.xlsx" ~ "SimFileA.xlsx",
#'                            ObsFile == "ObservedData2.xlsx" ~ "SimFileB.xlsx"))
#'
#'
#' 
ct_plot_overlay <- function(ct_dataframe,
                            obs_to_sim_assignment = NA,
                            mean_type = "arithmetic",
                            figure_type = "means only", 
                            linear_or_log = "semi-log",
                            colorBy_column,
                            color_labels = NA, 
                            legend_label_color = NA,
                            color_set = "default",
                            obs_shape = NA,
                            obs_color = NA,
                            obs_size = NA,
                            obs_fill_trans = NA, 
                            obs_line_trans = NA, 
                            linetype_column, 
                            linetypes = c("solid", "dashed"),
                            line_width = NA,
                            legend_label_linetype = NA,
                            facet1_column,
                            facet2_column, 
                            facet_ncol = NA, 
                            facet_nrow = NA,
                            floating_facet_scale = FALSE,
                            facet_spacing = NA,
                            time_range = NA, 
                            x_axis_interval = NA,
                            x_axis_label = NA,
                            pad_x_axis = TRUE,
                            pad_y_axis = TRUE,
                            y_axis_limits_lin = NA,
                            y_axis_limits_log = NA, 
                            y_axis_label = NA,
                            graph_labels = TRUE,
                            graph_title = NA,
                            graph_title_size = 14, 
                            legend_position = NA,
                            prettify_compound_names = TRUE,
                            save_graph = NA,
                            fig_height = 6,
                            fig_width = 5){
    
    # Error catching ---------------------------------------------------------
    # Check whether tidyverse is loaded
    if("package:tidyverse" %in% search() == FALSE){
        stop("The SimcypConsultancy R package also requires the package tidyverse to be loaded, and it doesn't appear to be loaded yet. Please run `library(tidyverse)` and then try again.", 
             call. = FALSE)
    }
    
    if(nrow(ct_dataframe) == 0){
        stop("Please check your input. The data.frame you supplied for ct_dataframe doesn't have any rows.", 
             call. = FALSE)
    }
    
    # Checking whether this is an enzyme abundance plot
    EnzPlot  <- all(c("Enzyme", "Abundance") %in% names(ct_dataframe))
    
    # Checking for more than one tissue or ADAM data type b/c there's only one y
    # axis and it should have only one concentration type.
    if(EnzPlot == FALSE && length(unique(ct_dataframe$Conc_units)) > 1){
<<<<<<< HEAD
        stop(paste("This function can only deal with one type of concentration unit at a time, and the supplied data.frame contains more than one non-convertable concentration unit. (Supplying some data in ng/mL and other data in mg/L is fine; supplying some in ng/mL and some in, e.g., 'cumulative fraction dissolved' is not.) Please supply a data.frame with only one type of concentration unit. To see what you've currently got, try this:
", deparse(substitute(ct_dataframe)), "%>% select(Tissue, subsection_ADAM, Conc_units) %>% unique()"),
             call. = FALSE)
    }
    
    if(length(unique(ct_dataframe$subsection_ADAM)) > 1){
        stop(paste("This function can only deal with one type of ADAM-model tissue at a time, and the supplied data.frame contains more than one. To see what you've got, try this:
", deparse(substitute(ct_dataframe)), "%>% select(subsection_ADAM) %>% unique()"),
call. = FALSE)
    }
    
=======
        stop("This function can only deal with one type of concentration unit at a time, and the supplied data.frame contains more than one non-convertable concentration unit. (Supplying some data in ng/mL and other data in mg/L is fine; supplying some in ng/mL and some in, e.g., 'cumulative fraction dissolved' is not.) Please supply a data.frame with only one type of concentration unit.",
             call. = FALSE)
    }
    
>>>>>>> master
    if(length(obs_color) > 1){
        warning("The argument `obs_color` can only take one color, and you've specified more than that. Only the first color will be used.", 
                call. = FALSE)
        obs_color <- obs_color[1]
<<<<<<< HEAD
    }
    
    # Cleaning up figure_type for the whole rest of the function
    if(str_detect(figure_type, "percentile") & !str_detect(figure_type, "ribbon")){
        figure_type <- "percentiles"
    } else if(str_detect(figure_type, "ribbon")){
        figure_type <- "percentile ribbon"
    }
    
    # Checking for acceptable input
    if(figure_type %in% c("means only", "percentiles", "percentile ribbon") == FALSE){
        warning(paste0("The value used for `figure_type` was `", 
                       figure_type,
                       "`, but only the only acceptable options are `means only`, `percentiles`, or `percentile ribbon`. The default figure type, `means only`, will be used."),
                call. = FALSE)
        figure_type <- "means only"
    }
    
    if(class(prettify_compound_names) != "logical" && 
       any(tolower(names(prettify_compound_names)) %in% 
           c("substrate", "inhibitor", "inhibitor 1", "primary metabolite 1", 
             "primary metabolite 2", "secondary metabolite", "inhibitor 2", 
             "inhibitor 1 metabolite"))){
        warning("You appear to have used compound IDs such as `substrate` or `inhibitor 1` or possibly `Inhibitor` to indicate which compound names should be prettified. Unfortunately, we need the actual original compound here, e.g., `prettify_compound_names = c('SV-Rifampicin-MD' = 'rifampicin')`. We will set `prettify_effector_names` to TRUE but will not be able to use the specific names you provided.",
                call. = FALSE)
        prettify_compound_names <- TRUE
    }
    
    # Checking whether user tried to include obs data directly from simulator
    # output for a simulation that included anything other than substrate in
    # plasma.
    if(any(unique(ct_dataframe$CompoundID) == "UNKNOWN")){
        return(
            ggplot(data.frame(Problem = 1, DataFail = 1), 
                   aes(y = Problem, x = DataFail)) +
                xlab("Please check the help file for extractConcTime") +
                theme(axis.title.x = element_text(size = 14, color = "red", 
                                                  face = "italic")) +
                annotate(geom = "text", x = 1, y = 1, size = 8,
                         color = "red", 
                         label = "You have extracted observed\ndata from a simulator output\nfile, but the simulator doesn't\ninclude information on\nwhat compound it is or\nwhether an effector was present.\nWe cannot make your graph.")
        )
    }
    
    
    # Main body of function -------------------------------------------------
    
    # Noting user's original preferences for a few things
    obs_line_trans_user <- obs_line_trans
    obs_fill_trans_user <- obs_fill_trans
    obs_color_user <- obs_color
    obs_shape_user <- obs_shape
    
    # Prettifying compound names before doing anything else 
    if(class(prettify_compound_names) == "logical"){ # NB: "prettify_compound_names" is the argument value
        if(prettify_compound_names){
            if(EnzPlot){ 
                ct_dataframe <- ct_dataframe %>% 
                    mutate(Inhibitor = prettify_compound_name(Inhibitor)) # NB: "prettify_compound_name" is the function
            } else {
                ct_dataframe <- ct_dataframe %>% 
                    mutate(Compound = prettify_compound_name(Compound), # NB: "prettify_compound_name" is the function
                           Inhibitor = prettify_compound_name(Inhibitor)) # NB: "prettify_compound_name" is the function 
            }
        } 
        # If prettify_compound_names is FALSE, then don't do anything.
        
    } else {
        # This is when the user has requested specific value for prettifying. 
        if(EnzPlot){ 
            # Any compounds that the user omitted from prettify_compound_names
            # should be added to that and kept as their original values.
            MissingNames <- setdiff(unique(ct_dataframe$Inhibitor), 
                                    names(prettify_compound_names))
            OrigPrettyNames <- prettify_compound_names
            prettify_compound_names <- c(prettify_compound_names, MissingNames)
            if(length(MissingNames) > 0){
                names(prettify_compound_names)[length(OrigPrettyNames) + 1] <- 
                    MissingNames
            }
            
            ct_dataframe <- ct_dataframe %>% 
                mutate(Inhibitor = prettify_compound_names[Inhibitor])
        } else {
            MissingNames <- setdiff(sort(unique(c(ct_dataframe$Compound,
                                                  ct_dataframe$Inhibitor))), 
                                    names(prettify_compound_names))
            MissingNames <- MissingNames[!MissingNames == "none"]
            OrigPrettyNames <- prettify_compound_names
            prettify_compound_names <- c(prettify_compound_names, MissingNames)
            if(length(MissingNames) > 0){
                names(prettify_compound_names)[length(OrigPrettyNames) + 1] <- 
                    MissingNames
            }
            
            ct_dataframe <- ct_dataframe %>% 
                mutate(Compound = prettify_compound_names[Compound], 
                       Inhibitor = prettify_compound_names[Inhibitor])
        }
    }
    
=======
    }
    
    # Cleaning up figure_type for the whole rest of the function
    if(str_detect(figure_type, "percentile") & !str_detect(figure_type, "ribbon")){
        figure_type <- "percentiles"
    } else if(str_detect(figure_type, "ribbon")){
        figure_type <- "percentile ribbon"
    }
    
    # Checking for acceptable input
    if(figure_type %in% c("means only", "percentiles", "percentile ribbon") == FALSE){
        warning(paste0("The value used for `figure_type` was `", 
                       figure_type,
                       "`, but only the only acceptable options are `means only`, `percentiles`, or `percentile ribbon`. The default figure type, `means only`, will be used."),
                call. = FALSE)
        figure_type <- "means only"
    }
    
    if(class(prettify_compound_names) != "logical" && 
       any(tolower(names(prettify_compound_names)) %in% 
           c("substrate", "inhibitor", "inhibitor 1", "primary metabolite 1", 
             "primary metabolite 2", "secondary metabolite", "inhibitor 2", 
             "inhibitor 1 metabolite"))){
        warning("You appear to have used compound IDs such as `substrate` or `inhibitor 1` or possibly `Inhibitor` to indicate which compound names should be prettified. Unfortunately, we need the actual original compound here, e.g., `prettify_compound_names = c('SV-Rifampicin-MD' = 'rifampicin')`. We will set `prettify_effector_names` to TRUE but will not be able to use the specific names you provided.",
                call. = FALSE)
        prettify_compound_names <- TRUE
    }
    
    # Checking whether user tried to include obs data directly from simulator
    # output for a simulation that included anything other than substrate in
    # plasma.
    if(any(unique(ct_dataframe$CompoundID) == "UNKNOWN")){
        return(
            ggplot(data.frame(Problem = 1, DataFail = 1), 
                   aes(y = Problem, x = DataFail)) +
                xlab("Please check the help file for extractConcTime") +
                theme(axis.title.x = element_text(size = 14, color = "red", 
                                                  face = "italic")) +
                annotate(geom = "text", x = 1, y = 1, size = 8,
                         color = "red", 
                         label = "You have extracted observed\ndata from a simulator output\nfile, but the simulator doesn't\ninclude information on\nwhat compound it is or\nwhether an effector was present.\nWe cannot make your graph.")
        )
    }
    
    
    # Main body of function -------------------------------------------------
    
    # Noting user's original preferences for a few things
    obs_line_trans_user <- obs_line_trans
    obs_fill_trans_user <- obs_fill_trans
    obs_color_user <- obs_color
    obs_shape_user <- obs_shape
    
    # Prettifying compound names before doing anything else 
    if(class(prettify_compound_names) == "logical"){ # NB: "prettify_compound_names" is the argument value
        if(prettify_compound_names){
            if(EnzPlot){ 
                ct_dataframe <- ct_dataframe %>% 
                    mutate(Inhibitor = prettify_compound_name(Inhibitor)) # NB: "prettify_compound_name" is the function
            } else {
                ct_dataframe <- ct_dataframe %>% 
                    mutate(Compound = prettify_compound_name(Compound), # NB: "prettify_compound_name" is the function
                           Inhibitor = prettify_compound_name(Inhibitor)) # NB: "prettify_compound_name" is the function 
            }
        } 
        # If prettify_compound_names is FALSE, then don't do anything.
        
    } else {
        # This is when the user has requested specific value for prettifying. 
        if(EnzPlot){ 
            # Any compounds that the user omitted from prettify_compound_names
            # should be added to that and kept as their original values.
            MissingNames <- setdiff(unique(ct_dataframe$Inhibitor), 
                                    names(prettify_compound_names))
            OrigPrettyNames <- prettify_compound_names
            prettify_compound_names <- c(prettify_compound_names, MissingNames)
            names(prettify_compound_names)[length(OrigPrettyNames) + 1] <- 
                MissingNames
            
            ct_dataframe <- ct_dataframe %>% 
                mutate(Inhibitor = prettify_compound_names[Inhibitor])
        } else {
            MissingNames <- setdiff(unique(c(ct_dataframe$Compound,
                                             ct_dataframe$Inhibitor)), 
                                    names(prettify_compound_names))
            OrigPrettyNames <- prettify_compound_names
            prettify_compound_names <- c(prettify_compound_names, MissingNames)
            names(prettify_compound_names)[length(OrigPrettyNames) + 1] <- 
                MissingNames
            
            ct_dataframe <- ct_dataframe %>% 
                mutate(Compound = prettify_compound_names[Compound], 
                       Inhibitor = prettify_compound_names[Inhibitor])
        }
    }
    
>>>>>>> master
    # Unless the user specifically set the levels for the Inhibitor column, we
    # always want "none" to be the 1st item on the legend for that, and we need
    # there to be some value present for "Inhibitor" for function to work
    # correctly.
    ct_dataframe <- ct_dataframe %>%
        mutate(Inhibitor = ifelse(is.na(Inhibitor), "none", Inhibitor))
    
    MyEffector <- unique(ct_dataframe$Inhibitor) %>% as.character()
    MyEffector <- MyEffector[!MyEffector == "none"]
    
    if(length(MyEffector) > 0 & class(ct_dataframe$Inhibitor) != "factor"){
        ct_dataframe <- ct_dataframe %>%
            mutate(Inhibitor = factor(Inhibitor, levels = c("none", MyEffector)))
    }
    
    # Things will be more consistent and easier to code if Individual is a
    # factor and is not NA. Adjusting that as needed.
    if(any(is.na(ct_dataframe$Individual))){
        ct_dataframe <- ct_dataframe %>%
            mutate(Individual = ifelse(is.na(Individual), 
                                       Trial, Individual))
    }
    
    if("Individual" %in% names(ct_dataframe) &&
       class(ct_dataframe$Individual) != "factor"){
        ct_dataframe <- ct_dataframe %>% 
            mutate(Individual = as.factor(Individual))
    }
    
    # Setting things up for nonstandard evaluation ----------------------------
    
    facet1_column <- rlang::enquo(facet1_column)
    facet2_column <- rlang::enquo(facet2_column)
    colorBy_column <- rlang::enquo(colorBy_column)
    linetype_column <- rlang::enquo(linetype_column)
    
    # I *would* be doing this whole function with nonstandard evaluation except
    # that I CANNOT figure out how to use NSE to redefine a user-supplied
    # column, so I'm going to have to rename all of them. This makes the rest of
    # checking and developing this function easier, too, though.
    
    # ct_dataframe <- ct_dataframe %>%
    #     mutate(colorBy_column = ifelse(as_label(colorBy_column) == "<empty>", NA, {{colorBy_column}}),
    #            FC1 = ifelse(as_label(facet1_column) == "<empty>", NA, {{facet1_column}}),
    #            FC2 = ifelse(as_label(facet2_column) == "<empty>", NA, {{facet2_column}}))
    
    ### NOT THE ABOVE. This causes everything to be the same value. Below code works. 
    
    # If user filled in color_labels but not colorBy_column, give a warning.
    if(as_label(colorBy_column) == "<empty>" & any(complete.cases(color_labels))){
        warning("You have specified something for `color_labels` but nothing for `colorBy_column`. Since R doesn't know which column contains the data to use for your color labels, they will be ignored.")
    }
    
    # If the color labels don't match the files available, give a warning.
    if(as_label(colorBy_column) != "<empty>" && 
       any(complete.cases(color_labels)) && 
<<<<<<< HEAD
       all(names(color_labels) %in% sort(unique(ct_dataframe[, as_label(colorBy_column)]))) == FALSE){
=======
       all(color_labels %in% unique(ct_dataframe[, as_label(colorBy_column)])) == FALSE){
>>>>>>> master
        BadLabs <- setdiff(names(color_labels), unique(ct_dataframe[, as_label(colorBy_column)]))
        
        warning(paste0("The labels you supplied for `color_labels` are not all present in the column ", 
                       as_label(colorBy_column), 
                       ". This will mess up the colors on your graph unless that's fixed. Specifically, the following values are not present in the column ",
                       as_label(colorBy_column), ": ", 
                       str_comma(BadLabs)), 
                call. = FALSE)
        
        WarningLabel <- paste0("WARNING: There's a mismatch between\nthe label given and the file name here", 
<<<<<<< HEAD
                               gsub(" - problem no. 1", "", paste(" - problem no.", 1:2)))
=======
                              gsub(" - problem no. 1", "", paste(" - problem no.", 1:2)))
>>>>>>> master
        color_labels[names(color_labels) %in% BadLabs] <- WarningLabel
        NewNames <- setdiff(unique(ct_dataframe[, as_label(colorBy_column)]), names(color_labels))
        NewNames <- NewNames[complete.cases(NewNames)]
        names(color_labels)[which(names(color_labels) %in% BadLabs)] <- NewNames
        rm(NewNames, BadLabs, WarningLabel)
    }
    
    if(as_label(colorBy_column) != "<empty>"){
        ct_dataframe <- ct_dataframe %>%
            mutate(colorBy_column = {{colorBy_column}})
        
        if(class(ct_dataframe$colorBy_column) == "numeric"){
            Levels <- sort(unique(ct_dataframe$colorBy_column))
            ct_dataframe <- ct_dataframe %>% 
                mutate(colorBy_column = factor(colorBy_column, levels = Levels))
        }
    }
    
    if(as_label(linetype_column) != "<empty>"){
        ct_dataframe <- ct_dataframe %>%
            mutate(linetype_column = {{linetype_column}})
        
        if(class(ct_dataframe$linetype_column) == "numeric"){
            Levels <- sort(unique(ct_dataframe$linetype_column))
            ct_dataframe <- ct_dataframe %>% 
                mutate(linetype_column = factor(linetype_column, levels = Levels))
        }
    }
    
    if(as_label(facet1_column) != "<empty>"){
        
        ct_dataframe <- ct_dataframe %>%
            mutate(FC1 = {{facet1_column}})
        
        if(length(unique(ct_dataframe$FC1)) == 1){
            warning(paste0("You requested the column `", 
                           as_label(facet1_column), 
                           "` for facet1_column, but that column contains only 1 unique value. Are you sure that's what you want?"), 
                    call. = FALSE)
        }
    }
    
    if(as_label(facet2_column) != "<empty>"){
        ct_dataframe <- ct_dataframe %>%
            mutate(FC2 = {{facet2_column}})
        
        if(length(unique(ct_dataframe$FC2)) == 1){
            warning(paste0("You requested the column `", 
                           as_label(facet2_column), 
                           "` for facet2_column, but that column contains only 1 unique value. Are you sure that's what you want?"), 
                    call. = FALSE)
        }
    }
    
    # Noting whether the tissue was from an ADAM model
    ADAM <- any(unique(ct_dataframe$Tissue) %in% c("stomach", "duodenum", "jejunum I",
                                                   "jejunum II", "ileum I", "ileum II",
                                                   "ileum III", "ileum IV", "colon", 
<<<<<<< HEAD
                                                   "faeces", "gut tissue",
                                                   "cumulative absorption", 
=======
                                                   "faeces", "cumulative absorption", 
>>>>>>> master
                                                   "cumulative dissolution")) &
        EnzPlot == FALSE
    
    if(length(time_range) == 1 && complete.cases(time_range[1]) &&
       !str_detect(time_range, "dose|last obs|all obs")){
        if(complete.cases(time_range)){
            warning("You have specified only 1 value for the time range and you don't appear to be specifying a time range by dose number, so we're not sure whether you want that to be the start or the end time. The full time range of all simulations will be used.",
                    call. = FALSE)
            time_range <- NA
        }
    } else {
        if(length(time_range) > 2){
            warning("You have specified more than 2 values for the time range, which only calls for a start time and an end time. Only the 1st two values you listed will be used for the time range.",
                    call. = FALSE)
            time_range <- time_range[1:2]
        } 
        
        if(class(time_range) != "numeric" && complete.cases(time_range[1]) &&
           !str_detect(time_range, "dose|last obs|all obs")){
            warning("You don't appear to be specifying a time range by dose number, and you have not specified numeric data for the start and end of your time range, which is the input required for this function if you're not supplying a dose number. The full time range will be used.",
                    call. = FALSE)
            time_range <- NA
        }
    }
    
    MyMeanType <- ct_dataframe %>%
        filter(Trial %in% c("geomean", "mean", "median")) %>% 
        pull(Trial) %>% unique() %>% 
        factor(levels = c("mean", "geomean", "median")) %>% 
        sort()
    
    if(switch(mean_type, "arithmetic" = "mean", "geometric" = "geomean",
              "median" = "median") %in% ct_dataframe$Trial == FALSE){
        
        warning(paste0("You requested the ", 
                       switch(mean_type, "arithmetic" = "arithmetic means",
                              "geometric" = "geometric means", 
                              "median" = "medians"), 
                       ", but those are not included in your data. Instead, the ",
                       ifelse(MyMeanType[1] == "mean", 
                              "arithmetic mean", MyMeanType[1]),
                       "s will be used."),
                call. = FALSE)
        MyMeanType <- MyMeanType[1] %>% as.character()
        mean_type <-  switch(MyMeanType,
                             "mean" = "arithmetic", 
                             "geomean" = "geometric",
                             "median" = "median")
        
    } else {
        
        MyMeanType <- switch(mean_type, "arithmetic" = "mean",
                             "geometric" = "geomean",
                             "median" = "median")
        
    }
    
    if(EnzPlot){ 
        # for enzyme abundance data
        ct_dataframe <- ct_dataframe %>%
            mutate(Group = paste(File, Trial, Tissue, Enzyme, Inhibitor), 
                   Abundance = Abundance / 100) %>% 
            rename(Conc = Abundance)
        
        sim_dataframe <- ct_dataframe
        
        obs_dataframe <- data.frame()
    } else {
        # for conc-time data
        ct_dataframe <- ct_dataframe %>%
<<<<<<< HEAD
=======
            # If it's dose number 0, remove those rows so that we'll show only the
            # parts we want when facetting and user wants scales to float freely.
            filter(DoseNum != 0 | Simulated == FALSE) %>% 
>>>>>>> master
            mutate(Group = paste(File, Trial, Tissue, CompoundID, Compound, Inhibitor),
                   CompoundID = factor(CompoundID,
                                       levels = c("substrate", "primary metabolite 1",
                                                  "primary metabolite 2", "secondary metabolite",
                                                  "inhibitor 1", "inhibitor 1 metabolite", 
                                                  "inhibitor 2"))) 
<<<<<<< HEAD
        
        if(all(complete.cases(ct_dataframe$DoseNum))){
            # If it's dose number 0, remove those rows so that we'll show only the
            # parts we want when facetting and user wants scales to float freely.
            ct_dataframe <- ct_dataframe %>% 
                filter(DoseNum != 0 | Simulated == FALSE)
        }
        
=======
>>>>>>> master
        sim_dataframe <- ct_dataframe %>%
            filter(Simulated == TRUE &
                       Trial %in% 
                       switch(figure_type, 
                              "means only" = MyMeanType, 
                              "percentiles" = c(MyMeanType, "per5", "per95"),
                              "percentile ribbon" = c(MyMeanType, "per5", "per95")))
        
        obs_dataframe <- ct_dataframe %>% filter(Simulated == FALSE) %>% 
            mutate(Trial = {MyMeanType})
    }
    
    # If the user set obs_color to "none", then they must not want to include
    # observed data in the graph. Set nrow to 0 in that case.
    if(complete.cases(obs_color) && obs_color == "none"){
        obs_dataframe <- filter(Trial == "mango") # hack to keep all the column names just in case
    }
    
    # Not mapping observed data to a column if File was originally NA for all
    # and that's what colorBy_column is or that's what linetype_column is. Also
    # not mapping if user has specified obs_color.
    MapObsFile_color <- nrow(obs_dataframe) > 0 && 
        as_label(colorBy_column) == "File" & all(is.na(obs_dataframe$File)) == FALSE
    MapObsFile_line <- nrow(obs_dataframe) > 0 && 
        as_label(linetype_column) == "File" & all(is.na(obs_dataframe$File)) == FALSE
    MapObsData <- ifelse(nrow(obs_dataframe) > 0 &&
                             ("File" %in% c(as_label(colorBy_column), as_label(linetype_column)) &
                                  all(is.na(obs_dataframe$File))) | complete.cases(obs_color_user),
                         FALSE, TRUE)
    
    # Setting this up so that observed data will be shown for all Files
    if(nrow(obs_dataframe) > 0 && 
       "File" %in% c(as_label(colorBy_column), as_label(facet1_column), 
                     as_label(facet2_column), as_label(linetype_column)) &&
       all(is.na(obs_dataframe$File))){
        
        ToAdd <- expand_grid(ObsFile = unique(obs_dataframe$ObsFile), 
                             File = unique(sim_dataframe$File))
        suppressMessages(
            obs_dataframe <- obs_dataframe %>% select(-File) %>% 
                left_join(ToAdd) %>% 
                mutate(Group = paste(File, Trial, Tissue, CompoundID,
                                     Compound, Inhibitor)))
        
        if(as_label(colorBy_column) == "File"){
            obs_dataframe <- obs_dataframe %>% 
                mutate(colorBy_column = File)
        }
        
        if(as_label(linetype_column) == "File"){
            obs_dataframe <- obs_dataframe %>% 
                mutate(linetype_column = File)
        }
    } 
    
    # Dealing with the fact that the observed data will list the inhibitor as
    # "inhibitor" unless the user changes it, but that sim data will list its
    # name
    if(nrow(obs_dataframe) > 0 & any(obs_dataframe$Inhibitor == "inhibitor")){
        sim_dataframe <- sim_dataframe %>% 
            mutate(Inhibitor = as.character(Inhibitor),
                   Inhibitor = ifelse(Inhibitor == "none",
                                      Inhibitor, "inhibitor"),
                   Inhibitor = factor(Inhibitor, levels = c("none", "inhibitor")))
    }
    
    # Now that all columns in both sim and obs data are filled in whenever they
    # need to be, setting factors for color_labels. 
    if(complete.cases(color_labels[1])){
        simcheck <- sim_dataframe %>% 
            filter(colorBy_column %in% names(color_labels)) %>% 
            select(colorBy_column) %>% unique() %>% pull()
        obscheck <- obs_dataframe %>% 
            filter(colorBy_column %in% names(color_labels)) %>% 
            select(colorBy_column) %>% unique() %>% pull()
        
        if(length(sort(unique(c(simcheck, obscheck)))) > 
           length(color_labels[names(color_labels) %in% sim_dataframe$colorBy_column])){
            warning(paste0("You have not included enough labels for the colors in the legend. The values in '",
                           as_label(colorBy_column), 
                           "' will be used as labels instead."),
                    call. = FALSE)
            color_labels <- NA
        } else {
            if(length(color_labels[names(color_labels) %in% sim_dataframe$colorBy_column]) == 0 |
               length(sort(unique(c(simcheck, obscheck)))) == 0){
                warning(paste0("There is some kind of mismatch between the color labels provided and the values actually present in ",
                               as_label(colorBy_column), ". The specified labels cannot be used."),
                        call. = FALSE)  
            } else {
                
                sim_dataframe <- sim_dataframe %>% 
                    mutate(colorBy_column = color_labels[colorBy_column], 
                           colorBy_column = factor(colorBy_column, levels = color_labels))
                
                obs_dataframe <- obs_dataframe %>% 
                    mutate(colorBy_column = color_labels[colorBy_column], 
                           colorBy_column = factor(colorBy_column, levels = color_labels))
            }
        }
    }
    
    # Not sure how I'm going to relabel the facets, actually. Commenting this
    # out for now.
    
    # if(complete.cases(facet1_labels[1])){
    #     simcheck <- sim_dataframe %>% 
    #         filter(FC1 %in% names(facet1_labels)) %>% 
    #         select(FC1) %>% unique() %>% pull()
    #     obscheck <- obs_dataframe %>% 
    #         filter(FC1 %in% names(facet1_labels)) %>% 
    #         select(FC1) %>% unique() %>% pull()
    #     
    #     if(length(sort(unique(c(simcheck, obscheck)))) > 
    #        length(facet1_labels[names(facet1_labels) %in% sim_dataframe$FC1])){
    #         warning(paste0("You have not included enough labels for number of unique values in ", 
    #                        as_label(FC1), 
    #                        ". The values will be used as labels instead."))
    #         facet1_labels <- NA
    #     } else {
    #         if(length(facet1_labels[names(facet1_labels) %in% sim_dataframe$FC1]) == 0 |
    #            length(sort(unique(c(simcheck, obscheck)))) == 0){
    #             warning(paste0("There is some kind of mismatch between the facet 1 labels provided and the values actually present in ",
    #                            as_label(FC1), ". The specified labels cannot be used."))  
    #             
    #             facet1_labels <- NA
    #         } 
    #     } # If facet1_labels is not NA at this point, apply those labels for the facets using labeller...? Not sure how this is going to work yet.
    # }
    # 
    # if(complete.cases(facet2_labels[1])){
    #     simcheck <- sim_dataframe %>% 
    #         filter(FC2 %in% names(facet2_labels)) %>% 
    #         select(FC2) %>% unique() %>% pull()
    #     obscheck <- obs_dataframe %>% 
    #         filter(FC2 %in% names(facet2_labels)) %>% 
    #         select(FC2) %>% unique() %>% pull()
    #     
    #     if(length(sort(unique(c(simcheck, obscheck)))) > 
    #        length(facet2_labels[names(facet2_labels) %in% sim_dataframe$FC2])){
    #         warning(paste0("You have not included enough labels for number of unique values in ", 
    #                        as_label(FC2), 
    #                        ". The values will be used as labels instead."))
    #         
    #         facet2_labels <- NA
    #         
    #     } else {
    #         if(length(facet2_labels[names(facet2_labels) %in% sim_dataframe$FC2]) == 0 |
    #            length(sort(unique(c(simcheck, obscheck)))) == 0){
    #             warning(paste0("There is some kind of mismatch between the facet 1 labels provided and the values actually present in ",
    #                            as_label(FC2), ". The specified labels cannot be used."))  
    #             
    #             facet2_labels <- NA
    #         }
    #     }
    # } # If facet2_labels is not NA at this point, apply those labels for the facets using labeller...? Not sure how this is going to work yet.
    
    AESCols <- c("color" = as_label(colorBy_column), 
                 "linetype" = as_label(linetype_column),
                 "facet1" = as_label(facet1_column), 
                 "facet2" = as_label(facet2_column))
    UniqueAES <- AESCols[which(AESCols != "<empty>")]
    
    AES <- names(AESCols[1:2])[!AESCols == "<empty>"]
    AES <- str_c(AES[complete.cases(AES)], collapse = "-")
    AES <- ifelse(AES == "" | is.na(AES), "none", AES)
    
    # If user didn't map linetype column but did specify more than one obs
    # shape, give them a warning that we'll only use the 1st shape specified b/c
    # we don't know what column to use to determine the shapes of the points.
    if(str_detect(AES, "linetype") == FALSE && complete.cases(obs_shape[1]) &&
       length(obs_shape) > 1){
        warning("You have specified multiple shapes to use for the observed data, but you have not said which column should determine what the shapes of the observed data should be. Since the shape is set by the same column that sets the line types, you can set this with the `linetype_column` argument. For now, only the 1st shape you specified will be used.", 
                call. = FALSE)
    }
    
    
    if(AESCols["color"] == "Individual"){
        # For ease of coding below, need to drop levels from obs data for
        # Individual here and then tweak them a few lines down.
        obs_dataframe <-
            obs_dataframe %>% mutate(Individual = droplevels(Individual))
        
        # If the user wants to color by Individual, presumably they want the
        # observed data to be colored by individual but still want the simulated
        # data to be black or gray. To deal with this, need to make a separate
        # column for individual observed data and will have to set the levels to the
        # obs individuals plus "simulated" to get things to be colored correctly and
        # show up in the legend correctly.
        ct_dataframe <- ct_dataframe %>% 
            mutate(SubjectID = ifelse(Simulated, "simulated", as.character(Individual)),
                   SubjectID = factor(SubjectID, levels = c(levels(obs_dataframe$Individual), 
                                                            "simulated")),
                   colorBy_column = SubjectID)
        sim_dataframe <- sim_dataframe %>% 
            mutate(SubjectID = ifelse(Simulated, "simulated", as.character(Individual)),
                   SubjectID = factor(SubjectID, levels = c(levels(obs_dataframe$Individual), 
                                                            "simulated")),
                   colorBy_column = SubjectID)
        obs_dataframe <- obs_dataframe %>% 
            mutate(SubjectID = ifelse(Simulated, "simulated", as.character(Individual)),
                   SubjectID = factor(SubjectID, levels = c(levels(obs_dataframe$Individual), 
                                                            "simulated")),
                   colorBy_column = SubjectID)
    }
    
    # RETURN TO THIS
    # # Need to check whether linetype or colorBy column was File b/c then we also
    # # need to set linetype or colorBy column in obs data. However, if there was
    # # only one observed data file for all the simulated data, then we do NOT
    # # want to change things b/c they're already set up correctly at this point.
    # if(str_detect(AES, "linetype") &&
    #    AESCols["linetype"] == "File" & MapObsFile_line == FALSE){
    #     obs_dataframe <- obs_dataframe %>% 
    #         mutate(linetype_column = File)
    # }
    # 
    # if(str_detect(AES, "color") &&
    #    AESCols["color"] == "File" & MapObsFile_color == FALSE){
    #     obs_dataframe <- obs_dataframe %>% 
    #         mutate(colorBy_column = File)
    # }
    
    # Checking whether small intestine and colon abundances are identical. 
    if(EnzPlot){
        Check <- sim_dataframe %>% 
            pivot_wider(names_from = Tissue, values_from = Conc)
        
        if(all(c("colon", "small intestine") %in% names(Check)) &&
           all(Check$colon == Check$`small intestine`, na.rm = TRUE)){
            warning("The enzyme abundances for colon and small intestine are identical in your data and thus would result in a plot where they perfectly overlap. We're going to combine them into one and show them together in your graph. ", 
                    "If you would like to avoid this behavior, try the following code, where `MyEnzData` is your input data.frame: 
                    MyEnzData <- MyEnzData %>% mutate(Tissue2 = Tissue)
                    ct_plot_overlay(ct_dataframe = MyEnzData, colorBy_column = Tissue2, ...)
Replace `colorBy_column` with whatever argument you want with ct_plot_overlay and replace the `...` with whatever other arguments you had.",
call. = FALSE)
            
            sim_dataframe <- sim_dataframe %>% filter(Tissue != "colon") %>% 
                mutate(Tissue = ifelse(Tissue == "small intestine", 
                                       "colon and small intestine", Tissue))
            
            if("color" %in% names(AESCols)[AESCols == "Tissue"]){
                sim_dataframe <- sim_dataframe %>% 
                    mutate(colorBy_column = Tissue)
            }
            
            if("linetype" %in% names(AESCols)[AESCols == "Tissue"]){
                sim_dataframe <- sim_dataframe %>% 
                    mutate(linetype_column = Tissue)
            }
            
            if("facet1" %in% names(AESCols)[AESCols == "Tissue"]){
                sim_dataframe <- sim_dataframe %>% 
                    mutate(FC1 = Tissue)
            }
            
            if("facet2" %in% names(AESCols)[AESCols == "Tissue"]){
                sim_dataframe <- sim_dataframe %>% 
                    mutate(FC2 = Tissue)
            }
            
        }
    }
    
    MyUniqueData <- sim_dataframe %>% 
        filter(Trial == MyMeanType) %>% 
        select(any_of(union(UniqueAES, 
                            c("File", "Tissue", "CompoundID", "Compound", "Enzyme", "Inhibitor")))) %>% 
        unique()
    
    UniqueGroups1 <- sim_dataframe %>% 
        summarize(across(.cols = any_of(union(UniqueAES, 
                                              c("File", "Tissue", "CompoundID",
                                                "Compound", "Inhibitor"))),
                         .fns = function(x) length(unique(x)))) 
    
    UniqueGroups <- UniqueGroups1 %>% 
        t() %>% as.data.frame() %>% 
        mutate(MyCols = rownames(.)) %>% 
        filter(V1 > 1) %>% pull(MyCols)
    
    
    # If there are only 2 groups for the colorBy_column and color_set was set to
    # "default", use Brewer set 1 instead of Brewer set 2 b/c it's more
    # aethetically pleasing.
    if(as_label(colorBy_column) != "<empty>" &&
       UniqueGroups1 %>% select(as_label(colorBy_column)) %>% pull(1) <= 2 &
       color_set[1] == "default"){
        color_set <- "Brewer set 1"
    }
    
    # Trying to give an indication to user about what data sets are present
    # compared to how many aesthetics have been specified. Basically trying to
    # get them to notice whether they've adequately clarified which dataset is
    # which in the graph.
    
    UniqueGroups <- ifelse(length(UniqueGroups) == 0, 
                           "none other than time and concentration", str_comma(sort(UniqueGroups)))
    message(paste("Columns that vary in your data:", UniqueGroups))
    message(paste("Graphing aesthetics you've assigned:", 
                  ifelse(length(UniqueAES) == 0, 
                         "none", 
                         str_comma(paste0(UniqueAES, " (", names(UniqueAES), ")")))))
    
    # If there are multiple values in linetype_column but user has only listed
    # the default "solid" for linetypes, then warn the user that they might want
    # to specify more line types.
    if(as_label(linetype_column) != "<empty>" && 
       as_label(colorBy_column) != as_label(linetype_column) &&
       length(unique(sim_dataframe$linetype_column)) > 1 & 
       length(unique(linetypes)) == 1){
        warning(paste0("There are ", length(unique(sim_dataframe$linetype_column)),
                       " unique values in the column ", as_label(linetype_column),
                       ", but you have only requested ", 
                       length(unique(linetypes)), " linetype(s): ", 
                       str_comma(unique(linetypes)), 
                       ". You may get a more interpretable graph if you specify more values for the argument 'linetypes'."),
                call. = FALSE)
    }
    
    # Some of the options inherited from ct_plot depend on there being just one
    # compound that the user is plotting. Using whatever is the compoundID that
    # has the base level for the factor. <--- This may not be necessary, now
    # that I think about it further...
    if(EnzPlot){
        AnchorCompound <- "substrate"
    } else {
        AnchorCompound <- sim_dataframe %>% select(CompoundID) %>% unique() %>% 
            mutate(CompoundLevel = as.numeric(CompoundID)) %>% 
            filter(CompoundLevel == min(CompoundLevel)) %>% 
            pull(CompoundID) %>% as.character()
    }
    
    # Setting up the x axis using the subfunction ct_x_axis
    ct_x_axis(Data = bind_rows(sim_dataframe, obs_dataframe),
              time_range = time_range, 
              t0 = "simulation start",
              x_axis_interval = x_axis_interval,
              pad_x_axis = pad_x_axis,
              compoundToExtract = AnchorCompound, 
              EnzPlot = EnzPlot)
    
    # Setting up the y axis using the subfunction ct_y_axis
    ct_y_axis(Data = bind_rows(sim_dataframe, obs_dataframe), 
              ADAM = ADAM, 
              subsection_ADAM = switch(as.character(EnzPlot), 
                                       "TRUE" = NA, 
                                       "FALSE" = unique(sim_dataframe$subsection_ADAM)), 
              prettify_compound_names = prettify_compound_names,
              EnzPlot = EnzPlot, 
              time_range_relative = time_range_relative,
              Ylim_data = bind_rows(sim_dataframe, obs_dataframe) %>%
                  mutate(Time_orig = Time), 
              pad_y_axis = pad_y_axis,
              y_axis_limits_lin = y_axis_limits_lin, 
              time_range = time_range,
              y_axis_limits_log = y_axis_limits_log)
    
    
    # Setting figure types and general aesthetics ------------------------------
    
    MyEffector <- unique(sim_dataframe$Inhibitor)
    MyEffector <- fct_relevel(MyEffector, before = "none")
    MyEffector <- sort(MyEffector)
    
    # Making linetype_column and colorBy_column factor data. This will
    # prevent errors w/mapping to color b/c ggplot expects only categorical data
    # for scale_color_manual, and, if the user supplies something that looks
    # like a number for the colorBy_column (e.g., a numerical SubjectID), it
    # will give the error message that a continuous value was supplied to a
    # discrete scale.
    if(as_label(linetype_column) != "<empty>" &&
       class(sim_dataframe$linetype_column) != "factor"){
        
        sim_dataframe$linetype_column <- as.factor(sim_dataframe$linetype_column)
        obs_dataframe$linetype_column <- as.factor(obs_dataframe$linetype_column)
    }
    
    if(as_label(colorBy_column) != "<empty>" &&
       class(sim_dataframe$colorBy_column) != "factor"){
        
        sim_dataframe$colorBy_column <- as.factor(sim_dataframe$colorBy_column)
        obs_dataframe$colorBy_column <- as.factor(obs_dataframe$colorBy_column)
    }
    
    # Taking care of linetypes and, along with that, obs_shape as needed
    if(as_label(linetype_column) != "<empty>"){
        NumLT <- length(sort(unique(sim_dataframe$linetype_column)))
    } else {
        NumLT <- 1
    }
    
    if(NumLT == 1){
        linetypes = "solid"
    } else if(NumLT < length(linetypes)){
        linetypes = linetypes[1:NumLT] 
    } else if(NumLT > length(linetypes)){
        warning(paste("There are", NumLT,
                      "unique values in the column you have specified for the line types, but you have only specified", 
                      length(linetypes), 
                      "line types to use. (Note that there are only two line types used by default: solid and dashed.) We will recycle the line types to get enough to display your data, but you probably will want to supply more line types and re-graph."), 
                call. = FALSE)
        linetypes = rep(linetypes, 100)[1:NumLT]
    } 
    
    if(as_label(linetype_column) != "<empty>"){
        
        # If the original data.frame included levels for linetype_column, then
        # use those levels. Otherwise, make "none" the base level since most of
        # the time, this will be used for the column "Inhibitor".
        if(class(sim_dataframe$linetype_column) != "factor"){
            if("none" %in% unique(sim_dataframe$linetype_column)){
                sim_dataframe <- sim_dataframe %>% 
                    mutate(linetype_column = forcats::fct_relevel(linetype_column, "none"))
                
                obs_dataframe <- obs_dataframe %>% 
                    mutate(linetype_column = factor(linetype_column, 
                                                    levels = c(levels(sim_dataframe$linetype_column), 
                                                               setdiff(obs_dataframe$linetype_column, 
                                                                       sim_dataframe$linetype_column))))
            } else {
                sim_dataframe$linetype_column <- as.factor(sim_dataframe$linetype_column)
                obs_dataframe$linetype_column <- as.factor(obs_dataframe$linetype_column)
            }
        }
    }
    
    if(str_detect(AES, "linetype")){
        NumShapes <- length(sort(unique(c(sim_dataframe$linetype_column,
                                          obs_dataframe$linetype_column))))
    } else {
        NumShapes <- 1
    }
    
    set_aesthet(line_type = linetypes, figure_type = figure_type,
                MyEffector = MyEffector, 
                compoundToExtract = switch(as.character(EnzPlot),
                                           "TRUE" = "substrate", 
                                           "FALSE" = unique(sim_dataframe$CompoundID)),
                obs_shape = obs_shape, obs_color = obs_color,
                obs_fill_trans = obs_fill_trans,
                obs_line_trans = obs_line_trans,
                # line_color is just a placeholder b/c not using it here.
                line_color = NA)
    
    if(length(obs_shape) < NumShapes){
        # This odd syntax will work both when obs_shape is a single value
        # and when it is multiple values.
        obs_shape <- rep(obs_shape, NumShapes)[1:NumShapes] 
    } else if(length(obs_shape) < NumShapes){
        obs_shape <- obs_shape[1:NumShapes] 
    }
    
    ## Figure type: means only ---------------------------------------------
    if(figure_type == "means only"){
        
        A <- ggplot(sim_dataframe %>% filter(Trial == MyMeanType),
                    switch(AES, 
                           "color-linetype" = aes(x = Time, y = Conc, 
                                                  color = colorBy_column, 
                                                  fill = colorBy_column,
                                                  linetype = linetype_column, 
                                                  group = Group, 
                                                  shape = linetype_column),
                           "color" = aes(x = Time, y = Conc, 
                                         color = colorBy_column, 
                                         fill = colorBy_column,
                                         group = Group), 
                           "linetype" = aes(x = Time, y = Conc, 
                                            linetype = linetype_column, 
                                            group = Group, shape = linetype_column),
                           "none" = aes(x = Time, y = Conc,
                                        group = Group))) +
            geom_line(lwd = ifelse(is.na(line_width), 1, line_width), 
                      show.legend = AESCols["color"] != "Individual")
        
    }
    
    ## Figure type: percentiles ---------------------------------------------
    
    if(figure_type == "percentiles"){
        
        A <- ggplot(sim_dataframe %>%
                        filter(Trial %in% c("per5", "per95")) %>%
                        mutate(Group = paste(Group, Trial)),
                    switch(AES, 
                           "color-linetype" = aes(x = Time, y = Conc,
                                                  color = colorBy_column,
                                                  fill = colorBy_column,
                                                  linetype = linetype_column,
                                                  group = Group,
                                                  shape = linetype_column),
                           "color" = aes(x = Time, y = Conc, 
                                         color = colorBy_column, 
                                         fill = colorBy_column,
                                         group = Group), 
                           "linetype" = aes(x = Time, y = Conc,
                                            linetype = linetype_column,
                                            group = Group, 
                                            shape = linetype_column),
                           "none" = aes(x = Time, y = Conc,
                                        group = Group))) +
            geom_line(alpha = 0.25,
                      lwd = ifelse(is.na(line_width), 0.8, line_width), 
                      show.legend = AESCols["color"] != "Individual") +
            geom_line(data = sim_dataframe %>% filter(Trial == MyMeanType),
                      lwd = ifelse(is.na(line_width), 1, line_width), 
                      show.legend = AESCols["color"] != "Individual")
    }
    
    ## Figure type: ribbon --------------------------------------------------
    if(str_detect(figure_type, "ribbon")){
        
        
        RibbonDF <-  sim_dataframe %>% 
            filter(Trial %in% c({MyMeanType}, "per5", "per95") &
                       # Ribbons don't work if any of the data are clipped on
                       # the x axis
                       Time >= time_range_relative[1] &
                       Time <= time_range_relative[2]) %>% 
            unique() %>% 
            select(-any_of(c("Group", "Individual"))) %>% 
            pivot_wider(names_from = Trial, values_from = Conc)
        names(RibbonDF)[names(RibbonDF) == MyMeanType] <- "MyMean"
        
        A <- ggplot(RibbonDF, 
                    switch(AES, 
                           "color-linetype" = aes(x = Time, y = MyMean, 
                                                  ymin = per5, ymax = per95, 
                                                  shape = linetype_column,
                                                  color = colorBy_column, 
                                                  fill = colorBy_column, 
                                                  linetype = linetype_column),
                           "linetype" = aes(x = Time, y = MyMean, 
                                            ymin = per5, ymax = per95, 
                                            linetype = linetype_column),
                           "color" = aes(x = Time, y = MyMean, 
                                         ymin = per5, ymax = per95, 
                                         color = colorBy_column, 
                                         fill = colorBy_column), 
                           "none" = aes(x = Time, y = MyMean, 
                                        ymin = per5, ymax = per95))) +
            geom_ribbon(alpha = 0.25, color = NA, 
                        show.legend = AESCols["color"] != "Individual") +
            geom_line(lwd = ifelse(is.na(line_width), 1, line_width), 
                      show.legend = AESCols["color"] != "Individual") 
        
    }
    
    # Observed data -----------------------------------------------
    
    if(nrow(obs_dataframe) > 0){
        
        # Checking whether to show obs data points in the legend. If the
        # column that is mapped to color or linetype has more than one item,
        # then show this in the legend. 
        LegCheck <- c(AESCols["color"], AESCols["linetype"])
        LegCheck <- LegCheck[LegCheck != "<empty>"]
        # If there's more than one unique value in whatever is in the color
        # or linetype column or the Inhibitor column, then include it
        if(length(LegCheck) == 0){
            LegCheck <- FALSE 
        } else if(length(LegCheck == 1)){
            LegCheck <- length(unique(obs_dataframe[, LegCheck])) > 1
        } else {
            LegCheck <- any(sapply(unique(obs_dataframe[, LegCheck]), length) > 1)
        }
        
        # Need to assign File to correct obs data. At this point, obs_dataframe WILL
        # have values for File if the user wanted the observed data to be
        # assigned to ALL the sim files. 
        if(all(is.na(obs_dataframe$File))){
            if(any(complete.cases(obs_to_sim_assignment))){
                # If the user *did* specify values for obs_data_assignment, then use
                # those for File.
                
                # Making sure that the split pattern will work in case the user omitted
                # spaces.
                obs_to_sim_assignment <- gsub(",[^ ]", ", ", obs_to_sim_assignment)
                ObsAssign <- str_split(obs_to_sim_assignment, pattern = ", ")
                
                if(all(sapply(ObsAssign, length) == 1)){
                    obs_dataframe <- obs_dataframe %>% mutate(File = obs_to_sim_assignment[ObsFile])
                } else {
                    obs_dataframe <- split(as.data.frame(obs_dataframe), f = obs_dataframe$ObsFile)
                    
                    for(j in 1:length(ObsAssign)){
                        FileAssign <- expand_grid(ObsFile = names(obs_to_sim_assignment)[j], 
                                                  File = ObsAssign[[j]])
                        suppressMessages(
                            obs_dataframe[[j]] <- FileAssign %>% full_join(obs_dataframe[[j]] %>% select(-File))
                        )
                        rm(FileAssign)
                    }
                    obs_dataframe <- bind_rows(obs_dataframe)
                }
            }
            
        } else {
            # If there are some assignments for File but some missing, just warn
            # the user about that b/c it's not clear how to assign the ones that
            # are missing.
            if(any(is.na(obs_dataframe$File)) & any(complete.cases(obs_dataframe$File))){
                warning("You have supplied a data.frame with some of the observed data assigned to specific simulator files and some of the observed data unassigned, so we don't know what file to match with the unassigned observed data and will thus ignore those observed data.", 
                        call. = FALSE)
                obs_dataframe <- obs_dataframe %>% filter(complete.cases(File))
            }
        }
        
        A <- addObsPoints(obs_data = obs_dataframe, 
                          A = A, 
                          AES = AES,
                          obs_shape = obs_shape,
                          obs_shape_user = obs_shape_user,
                          obs_size = obs_size, 
                          obs_color = obs_color,
                          obs_color_user = obs_color_user,
                          obs_line_trans = obs_line_trans,
                          obs_line_trans_user = obs_line_trans_user,
                          obs_fill_trans = obs_fill_trans,
                          obs_fill_trans_user = obs_fill_trans_user,
                          figure_type = figure_type,
                          MapObsData = MapObsData, 
                          LegCheck = LegCheck)
    }
    
    
    # Making linear graph --------------------------------------------------------
    
    if((class(y_axis_label) == "character" && complete.cases(y_axis_label)) |
       (class(y_axis_label) == "expression" && length(y_axis_label) > 0)){
        ylab <- y_axis_label
    }
    
    if((class(x_axis_label) == "character" && complete.cases(x_axis_label)) |
       (class(x_axis_label) == "expression" && length(x_axis_label) > 0)){
        xlab <- x_axis_label
    }
    
    A <-  A +
        xlab(xlab) +
        ylab(ylab) +
        theme_consultancy() +
        theme(panel.border = element_rect(color = "black", fill = NA)) # KEEP THIS
    
    # Error catching
    if((complete.cases(facet_ncol) | complete.cases(facet_nrow)) == TRUE & 
       AESCols["facet1"] == "<empty>" & AESCols["facet2"] == "<empty>"){
        warning("You have specified the number of columns and/or rows you want in your facetted graph, but you have not specified *how* you want to break up the data. Please set a value for either `facet1_column` or `facet2_column` to do that. For now, the graph will not be facetted.", 
                call. = FALSE)
        facet_ncol <- NA
        facet_nrow <- NA
    }
    
    if(floating_facet_scale){
        
        strip.position <- ifelse(complete.cases(facet_ncol) && 
                                     facet_ncol == 1 & is.na(facet_nrow), 
                                 "right", "top")
        
        A <- A + 
            facet_wrap(vars(!!facet1_column, !!facet2_column), 
                       scales = "free", 
                       ncol = switch(as.character(is.na(facet_ncol)),
                                     "TRUE" = NULL, 
                                     "FALSE" = facet_ncol),
                       nrow = switch(as.character(is.na(facet_nrow)),
                                     "TRUE" = NULL, 
                                     "FALSE" = facet_nrow), 
                       strip.position = strip.position)
        
        if(EnzPlot){
            A <- A +
                scale_y_continuous(expand = expansion(mult = pad_y_num),
                                   labels = scales::percent)
        } else {
            A <- A +
                scale_y_continuous(expand = expansion(mult = pad_y_num))
        }
        
        if(complete.cases(x_axis_interval)){
            A <- A + scale_x_continuous(expand = expansion(
                mult = pad_x_num), breaks = XBreaks, labels = XLabels)
        } else {
            A <- A + scale_x_continuous(expand = expansion(
                mult = pad_x_num))
        }
        
    } else if(complete.cases(facet_ncol) | complete.cases(facet_nrow)){
        
        suppressWarnings(
            A <- A +
                coord_cartesian(xlim = time_range_relative, 
                                ylim = c(ifelse(is.na(y_axis_limits_lin[1]), 
                                                0, y_axis_limits_lin[1]),
                                         YmaxRnd)) +
                scale_x_continuous(breaks = XBreaks, labels = XLabels,
                                   expand = expansion(
                                       mult = pad_x_num)) +
                facet_wrap(switch(paste(AESCols["facet1"] == "<empty>",
                                        AESCols["facet2"] == "<empty>"), 
                                  "TRUE FALSE" = vars(!!facet2_column),
                                  "FALSE TRUE" = vars(!!facet1_column),
                                  "FALSE FALSE" = vars(!!facet1_column, !!facet2_column)),
                           ncol = facet_ncol, nrow = facet_nrow)
        )
        
        if(EnzPlot){
            A <- suppressWarnings(suppressMessages(
                A + scale_y_continuous(labels = scales::percent,
                                       expand = expansion(mult = pad_y_num)) 
            ))
        } else {
            A <- suppressWarnings(suppressMessages(
                A + scale_y_continuous(breaks = YBreaks, labels = YLabels,
                                       expand = expansion(mult = pad_y_num)) 
            ))
        }
        
    } else {
        A <- A +
            coord_cartesian(xlim = time_range_relative, 
                            ylim = c(ifelse(is.na(y_axis_limits_lin[1]), 
                                            0, y_axis_limits_lin[1]),
                                     YmaxRnd)) +
            scale_x_continuous(breaks = XBreaks, labels = XLabels,
                               expand = expansion(
                                   mult = pad_x_num)) +
            facet_grid(rows = vars(!!facet1_column), cols = vars(!!facet2_column)) 
        
        if(EnzPlot){
            A <- suppressWarnings(suppressMessages(
                A + scale_y_continuous(labels = scales::percent,
                                       expand = expansion(mult = pad_y_num))
            ))
        } else {
            A <- suppressWarnings(suppressMessages(
                A + scale_y_continuous(breaks = YBreaks,
                                       labels = YLabels,
                                       expand = expansion(mult = pad_y_num))
            ))
        }
    }
    
    # Colors, linetypes, & legends -------------------------------------------
    
    if(AES %in% c("color", "color-linetype")){
        
        # Calculating the number of colors needed
        
        # If the user requests the column Individual for colorBy_column, they
        # most likely want each observed individual to be a different color but
        # the aggregate simulated data to be the usual colors (black or gray).
        # NumColorsNeeded should only include the obs data in that scenario.
        if(AESCols["color"] == "Individual"){
            NumColorsNeeded <- obs_dataframe %>% 
                pull(colorBy_column) %>% unique() %>% length()
        } else {
            NumColorsNeeded <-
                ifelse(MapObsData,
                       bind_rows(sim_dataframe, obs_dataframe) %>% 
                           pull(colorBy_column) %>% unique() %>% length(),
                       sim_dataframe %>% 
                           pull(colorBy_column) %>% unique() %>% length())
            
        }
        
        # If there's only one unique value in the colorBy_column, then make that
        # item black.
        if(length(sort(unique(c(sim_dataframe$colorBy_column, 
                                obs_dataframe$colorBy_column)))) == 1){
            A <- A + scale_color_manual(values = "black") +
                scale_fill_manual(values = "black")
        } else {
            
            # This is when the user wants specific user-specified colors rather
            # that one of the pre-made sets.
            if(length(color_set) > 1){
                
                # If they supply a named character vector whose values are not
                # present in the data, convert it to an unnamed character vector.
                if(is.null(names(color_set)) == FALSE && 
                   all(unique(sim_dataframe$colorBy_column) %in% names(color_set) == FALSE)){
                    warning(paste0("You have provided a named character vector of colors, but some or all of the items in the column ", 
                                   as_label(colorBy_column),
                                   " are not included in the names of the vector. We will not be able to map those colors to their names and will instead assign colors in the alphabetical order of the unique values in ",
                                   as_label(colorBy_column), "."), 
                            call. = FALSE)
                    
                    MyColors <- as.character(color_set)
                } else if(length(color_set) < NumColorsNeeded){
                    warning(paste("There are", NumColorsNeeded,
                                  "unique values in the column you have specified for the colors, but you have only specified", 
                                  length(color_set), 
                                  "colors to use. We will recycle the colors to get enough to display your data, but you probably will want to supply more colors and re-graph."), 
                            call. = FALSE)
                    
                    MyColors <- rep(color_set, 100)[1:NumColorsNeeded]
                } else {
                    MyColors <- color_set
                }
                
            } else {
                
                # NOTE: For no reason I can discern, if the user has observed
                # data that should be all one color but then uses scale_color_X
                # where x is anything except "manual", the observed points
                # DISAPPEAR. That's why, below, whenever it's scale_color_x, I'm
                # setting the colors needed and then using scale_color_manual
                # instead of scale_color_x. -LSh
                
                color_set <- ifelse(str_detect(tolower(color_set), 
                                               "default|brewer.*2|set.*2"), 
                                    "set2", color_set)
                color_set <- ifelse(str_detect(tolower(color_set),
                                               "brewer.*1|set.*1"), 
                                    "set1", color_set)
                
                
                suppressWarnings(
                    MyColors <- 
                        switch(
                            color_set,
                            # Using "Dark2" b/c "Set2" is just really,
                            # really light.
                            "set2" = RColorBrewer::brewer.pal(NumColorsNeeded, "Dark2")[
                                1:NumColorsNeeded], 
                            "blue-green" = blueGreens(NumColorsNeeded),
                            "blues" = blues(NumColorsNeeded),
                            "rainbow" = rainbow(NumColorsNeeded),
                            "set1" = RColorBrewer::brewer.pal(NumColorsNeeded, "Set1")[
                                1:NumColorsNeeded],
                            "Tableau" = ggthemes::tableau_color_pal(
                                palette = "Tableau 10")(NumColorsNeeded),
                            "viridis" = viridis::viridis_pal()(NumColorsNeeded))
                )
                # NB: For the RColorBrewer palettes, the minimum number of
                # colors you can get is 3. Since sometimes we might only want 1
                # or 2 colors, though, we have to add the [1:NumColorsNeeded]
                # bit.
                
                if(any(is.na(MyColors))){
                    warning("The color set you requested does not have enough values for the number of colors required. We're switching the color set to `rainbow` for now.", 
                            call. = FALSE)
                    
                    MyColors <- rainbow(NumColorsNeeded)
                }
            }
            
            if(MapObsFile_color){
                names(MyColors) <- unique(bind_rows(sim_dataframe, obs_dataframe) %>% 
                                              arrange(colorBy_column) %>% 
                                              pull(colorBy_column))
            } else if(length(color_set) == 1){
                if(AESCols["color"] == "Individual"){
                    # Figuring out all the colorBy_column values
                    AllCBC <- levels(bind_rows(sim_dataframe, obs_dataframe) %>% 
                                         pull(colorBy_column))
                    
                    MyColors <- c(MyColors, "black")
                    names(MyColors) <- levels(ct_dataframe$colorBy_column)
                    
                } else {
                    # This is when the colors are NOT set by the observed file
                    # AND the user hasn't supplied a named character vector for
                    # how to assign the colors AND the colors are not assigned
                    # to the individual subject.
                    names(MyColors) <- levels(sim_dataframe$colorBy_column)
                }
            }
            
            suppressWarnings(
                A <-  A + scale_color_manual(values = MyColors) +
                    scale_fill_manual(values = MyColors)
            )
        }
    }
    
    # Specifying linetypes
    A <- A + scale_linetype_manual(values = linetypes)
    
    # Adding legend label for color and linetype as appropriate
    if(complete.cases(legend_label_color)){
        if(legend_label_color == "none"){    
            A <- A + labs(color = NULL, fill = NULL)
        } else {
            A <- A + labs(color = legend_label_color, 
                          fill = legend_label_color)
        }
    } else {
        # This is when no legend_label_color has been specified.
        if(complete.cases(color_labels[1])){
            # If user did not request a label on the legend for color but DID
            # set any of the color labels, that means that the legend label for
            # color probably should NOT be the same as the column title. Do not
            # include a legend label for color in that scenario.
            A <- A + labs(color = NULL, fill = NULL)
        } else if(AES %in% c("color", "color-linetype")){
            # However, if they did not include anything for legend_label_color
            # but there *is* a column that is mapped to color, then they
            # probably do want the title for colors on the legend to be the same
            # as the colorBy_column name.
            A <- A + labs(color = as_label(colorBy_column), 
                          fill = as_label(colorBy_column))
        } 
        
        # None of these conditions are met when 1) they did NOT set anything for the
        # legend_label_color, 2) they did not specify any alternative label
        # for each value in the colorBy_column for the legend, and 3) the
        # specified aesthetics do NOT include color or linetype.
        
    }
    
    if(complete.cases(legend_label_linetype) && 
       legend_label_linetype == "none"){
        A <- A + labs(linetype = NULL)
    } else if(as_label(linetype_column) != "<empty>"){
        A <- A + labs(linetype = switch(as.character(complete.cases(legend_label_linetype)), 
                                        "TRUE" = legend_label_linetype,
                                        "FALSE" = as_label(linetype_column)), 
                      shape = switch(as.character(complete.cases(legend_label_linetype)), 
                                     "TRUE" = legend_label_linetype,
                                     "FALSE" = as_label(linetype_column)))
        
        if(any(linetypes != "solid")){
            # When the linetype is dashed (or possibly some other user-specified
            # line type that I'm not even considering), then the legend glyph
            # often cuts off the 2nd dash and it's unclear how solid vs. dashed
            # lines differ in the legend. Fixing that here.
            A <- A + theme(legend.key.width = unit(2, "lines"))
        }
    }
    
    ## Adding spacing between facets if requested
    if(complete.cases(facet_spacing)){
        A <- A + theme(panel.spacing = unit(facet_spacing, "lines"))
    }
    
    # If any of the items in the legend have length = 1, don't show that in the
    # legend.
    if(AES %in% c("linetype", "color-linetype") &&
       (length(unique(sim_dataframe$linetype_column)) == 1 | 
        length(unique(linetypes)) == 1)){
        A <- A + guides(linetype = "none") 
    }
    
    if(AES %in% c("color", "color-linetype") &&
       length(unique(bind_rows(sim_dataframe, obs_dataframe) %>% 
                     pull(colorBy_column))) == 1){
        A <- A + guides(color = "none", fill = "none")
    }
    
    ## Making semi-log graph ------------------------------------------------
    
    LowConc <- bind_rows(sim_dataframe, obs_dataframe) %>%
        filter(Trial %in% c("mean", "per5", "per95") &
                   Time > 0 &
                   Conc < Ylim_log[1]) %>% 
        pull(Conc)
    
    if(length(LowConc) > 0 & str_detect(figure_type, "ribbon")){
        warning(paste0("Some of your data are less than the lower y axis value of ",
                       Ylim_log[1], ". When plotting a figure type of `percentile ribbon`, this sometimes leads to the ribbon being disjointed or disappearing entirely and isn't something the SimcypConsultancy package controls. If this happens to your graph, please try setting the minimum value for the y axis to less than or equal to ",
                       min(LowConc, na.rm = T), 
                       ", the lowest value in your data."),
                call. = FALSE)
    }
    
    if(EnzPlot){
        B <- suppressMessages(suppressWarnings(
            A + scale_y_log10(labels = scales::percent, 
                              expand = expansion(mult = pad_y_num)) +
                switch(as.character(floating_facet_scale), 
                       "TRUE" = coord_cartesian(ylim = Ylim_log), 
                       "FALSE" = coord_cartesian(ylim = Ylim_log, 
                                                 xlim = time_range_relative))
        ))
    } else {
        B <- suppressMessages(suppressWarnings(
            A + scale_y_log10(labels = YLogLabels, breaks = YLogBreaks,
                              expand = expansion(mult = pad_y_num)) +
                switch(as.character(floating_facet_scale), 
                       "TRUE" = coord_cartesian(ylim = Ylim_log), 
                       "FALSE" = coord_cartesian(ylim = Ylim_log, 
                                                 xlim = time_range_relative))
        ))
    }
    
    if(complete.cases(legend_position)){
        A <- A + theme(legend.position = legend_position)  
        B <- B + theme(legend.position = legend_position)
    }    
    
    if(graph_labels){
        labels <- "AUTO"
    } else {
        labels <- NULL
    }
    
    # both plots together, aligned vertically
    AB <- suppressWarnings(
        ggpubr::ggarrange(A, B, ncol = 1, 
                          labels = labels, 
                          font.label = list(size = graph_title_size),
                          common.legend = TRUE, align = "hv", 
                          legend = ifelse(is.na(legend_position), 
                                          "right", legend_position))
    )
    
    # both plots together, aligned horizontally
    ABhoriz <- suppressWarnings(
        ggpubr::ggarrange(A, B, ncol = 2, 
                          labels = labels, 
                          font.label = list(size = graph_title_size),
                          common.legend = TRUE, align = "hv", 
                          legend = ifelse(is.na(legend_position), 
                                          "bottom", legend_position))
    )
    
    if(complete.cases(graph_title)){
        A <- A + ggtitle(graph_title) +
            theme(plot.title = element_text(hjust = 0.5, size = graph_title_size))
        B <- B + ggtitle(graph_title) +
            theme(plot.title = element_text(hjust = 0.5, size = graph_title_size))
        AB <- ggpubr::annotate_figure(
            AB, top = ggpubr::text_grob(graph_title, hjust = 0.5, 
                                        face = "bold", size = graph_title_size))
        ABhoriz <- ggpubr::annotate_figure(
            ABhoriz, top = ggpubr::text_grob(graph_title, hjust = 0.5,
                                             face = "bold", size = graph_title_size))
    }
    
    Out <- switch(linear_or_log, 
                  "linear" = A,
                  "semi-log" = B,
                  "log" = B,
                  "both" = AB, 
                  "both vertical" = AB,
                  "both horizontal" = ABhoriz)
    
    if(complete.cases(save_graph)){
        FileName <- save_graph
        if(str_detect(FileName, "\\.")){
            # Making sure they've got a good extension
            Ext <- sub("\\.", "", str_extract(FileName, "\\..*"))
            FileName <- sub(paste0(".", Ext), "", FileName)
            Ext <- ifelse(Ext %in% c("eps", "ps", "jpeg", "tiff",
                                     "png", "bmp", "svg", "jpg", "docx"), 
                          Ext, "png")
            FileName <- paste0(FileName, ".", Ext)
        } else {
            FileName <- paste0(FileName, ".png")
            Ext <- "png"
        }
        
        if(Ext == "docx"){
            
            # This is when they want a Word file as output
            OutPath <- dirname(FileName)
            if(OutPath == "."){
                OutPath <- getwd()
            }
            
            # Check for whether they're trying to save on SharePoint, which DOES
            # NOT WORK. If they're trying to save to SharePoint, instead, save
            # to their Documents folder.
            
            # Side regex note: The myriad \ in the "sub" call are necessary b/c
            # \ is an escape character, and often the SharePoint and Large File
            # Store directory paths start with \\\\.
            if(str_detect(sub("\\\\\\\\", "//", OutPath), SimcypDir$SharePtDir)){
                
                OutPath <- paste0("C:/Users/", Sys.info()[["user"]], 
                                  "/Documents")
                warning(paste0("You have attempted to use this function to save a Word file to SharePoint, and Microsoft permissions do not allow this. We will attempt to save the ouptut to your Documents folder, which we think should be ", 
                               OutPath,
                               ". Please copy the output to the folder you originally requested or try saving locally or on the Large File Store."), 
                        call. = FALSE)
            }
            
            LFSPath <- str_detect(sub("\\\\\\\\", "//", OutPath), SimcypDir$LgFileDir)
            
            if(LFSPath){
                # Create a temporary directory in the user's AppData/Local/Temp
                # folder.
                TempDir <- tempdir()
                
                # Upon exiting this function, delete that temporary directory.
                on.exit(unlink(TempDir))
                
            }
            
            FileName <- basename(FileName)
            
            rmarkdown::render(system.file("rmarkdown/templates/multctplot/skeleton/skeleton.Rmd",
                                          package="SimcypConsultancy"), 
                              output_dir = switch(as.character(LFSPath), 
                                                  "TRUE" = TempDir,
                                                  "FALSE" = OutPath),
                              output_file = FileName, 
                              quiet = TRUE)
            # Note: The "system.file" part of the call means "go to where the
            # package is installed, search for the file listed, and return its
            # full path.
            
            if(LFSPath){
                file.copy(file.path(TempDir, FileName), OutPath, overwrite = TRUE)
            }
            
            
        } else {
            # This is when they want any kind of graphical file format.
            if(linear_or_log %in% c("both", "both vertical")){
                ggsave(FileName, height = fig_height, width = fig_width, dpi = 600,
                       plot = AB)
            }
            
            if(linear_or_log %in% c("both horizontal")){
                ggsave(FileName, height = fig_height, width = fig_width, dpi = 600,
                       plot = ABhoriz)
            }
            
            if(linear_or_log == "linear"){
                ggsave(FileName, height = fig_height, width = fig_width, dpi = 600, 
                       plot = A)
            }
            
            if(str_detect(linear_or_log, "log")){
                ggsave(FileName, height = fig_height, width = fig_width, dpi = 600, 
                       plot = B)
            }
        }
    }
    
    return(Out)
    
}




